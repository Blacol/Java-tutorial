# 2-1 Java虚拟机初步
## 本章任务
- [ ] 掌握Java虚拟机的基本结构
- [ ] 了解变量、对象的内存分布方法

## Java虚拟机回顾

在基础篇时有提到JVM。JVM是执行Java代码所必须拥有的一个结构。

在基础篇中我们提到JVM只负责执行Java程序，那如何执行是没有讲到的，在本章会进行详细的讲解。

## JVM模型

![图 9](https://s2.loli.net/2023/09/26/ayG85gwvRuU9Amo.png)  

上图为JVM的模型。在编译好后，会将class文件放入类加载器中并读取类的信息，类和JVM之间进行数据的交换。交换的数据有类中方法、类中的成员变量、类中的局部变量等等信息。上图是Java 7以及之前版本中的内存模型。

在下面的JVM框架中有以下几个部分：
1. 方法区（元数据区）
2. 堆
3. 栈

首先来说一下方法区。方法区存放JVM加载完成的类型信息、常量、静态变量、即时编译器编译后的代码缓存。虽然它叫方法区但并不保存方法而是保存数据的。在高版本（Java 8及以后）中方法区被叫做元数据区。

堆是虚拟机中的另一种结构，**我们所有通过`new`关键字创建的对象也存放在这里。同时还有字符串常量。** 当我们直接对一个变量赋予`"hello"`这个字符串时，`"hello"`这个字符串会被存储在堆中。而变量中会存储字符串所在的地址。关于地址的内容本章节后面会有讲到。

栈分为两个：虚拟机栈和本地方法栈。虚拟机栈用来存储 **当前正在执行的方法以及其内部的各种数据。** 而本地方法栈则存储`native`方法。关于`native`方法可以理解为是Java和C语言之间的一种联动即可。

## 变量内存分配

在上一部分中我们知道每一个区域都存储哪些数据，那么各个区域之间又是如何协作的？在此之前先补充一些内容。

### 指针、引用与地址

如果学习过C语言或者C++语言肯定会知道指针和地址。在Java中并不会提供允许程序员操作的指针但Java内部确实有**指针的概念**。其实具体而言也不知道这种引用应该称作什么。在目前主流的学习资料中称作指针、引用或者`refrence`偏多。那么本教程使用引用称呼，正好可以和引用数据类型产生关联，很多引用数据类型在方法中的传递和C系指针有很多相似之处。

为了让各位读者理解指针，这里使用一些图片帮助理解。

在程序运行时会为程序分配内存，每一块内存都有一个地址。指针就是保存内存地址的一个东西。就像每个人的房子都有地址一样，指针就是记录房子地址的东西。当直接获取指针的内容时返回的是内存地址。在计算机中，内存地址通常使用十六进制数表示。而只有通过特定符号确定要获取内存中的内容时才会获取内存中存储的值。

![图 5](https://s2.loli.net/2023/09/26/Y2G3p8S9eBH5MFC.png)  

上图就是指针的一个示例，指针a指向了0xa0这块内存。那么所有对于a的操作都是有可能反映到内存中的。这也就是为什么C系语言十分灵活，但这也带来了一些问题，一些木马程序会通过指针来破坏内存数据进而引发系统崩溃或者植入木马。因此在后期诞生的很多编程语言中并不会提供供程序员操作的指针，比如Java。

### 内存分配
#### 常量内存分配
在理解了内存地址以及引用后我们就可以详细的学习内存的分配了。在Java中，常量在堆和方法栈中都有存储。在这里讲解一下运行时常量池和字符串常量池。

运行时常量池是指程序运行时产生的各种编译信息以及类的相关信息（字段信息等）都会存储在这里。**运行时常量池在方法区中**，在JDK 1.8及以后的版本中（Java 8及以后），**运行时常量池在元数据区中**，而元数据区已经脱离了JVM架构。

这里给各位看一下Java 8及以后版本的JVM结构。

![图 6](https://s2.loli.net/2023/09/26/4pcMnd7uBOC61SI.png)  

字符串常量池则保存大量的字符串常量。通过非`new`关键字所创建的字符串都会存储在这里。字符串常量池位于堆中。关于字符串的内存分配也是面试经常考察的内容。

为了更好的理解字符串的内存分配使用下面的代码来进行讲解。

```java
String a="hello";
String b=new String();
b="hello";
String c=new String("hello2");
String d=new String();
d="hello2"；
System.out.println(a==b);
System.out.println(a==c);
System.out.println(a==d);
System.out.println(b==c);
System.out.println(b==d);
System.out.println(c==d);
```
我们将这段代码放入主函数中执行，观察运行结果：
![图 7](https://s2.loli.net/2023/09/26/F7VcxQ86daN4brf.png)  

可以看到只有a==b是真的，其他的都是假。产生疑问的肯定是b和a为什么不相等？字符串是一样的，还有c和d为什么也不相等，存储的字符串也是一样的呀。

这就需要强调以下Java中`==`的作用，当`==`两边是引用数据类型时，`==`比对的是两个**引用数据类型变量引用的地址**而不是值。之前又提到过，new产生的对象存入堆中，而字符串常量存储在常量池中。但这样的话a和b理论上应该不相等，为什么最后还是相等了？因为在定义字符串类型时会先寻找常量池中是否有内容一样的字符串，如果有则让变量**引用常量池中的**字符串而不是再创建一块内存来存储字符串。因此b引用了a中的"hello"所以地址是一样的，故最后就是a==b。

这也就是为什么基础篇中比对两个字符串是否相同使用`equals`方法而不使用`==`的原因。

那c和d为什么不相等呢？通过`new`关键字定义的对象都保存在了堆中，而对象c创建时将`hello2`一同保存在了堆中，所以常量池中没有`hello2`字符串故无法让d去引用字符串，所以c和d不相等。

如果让b在new的时候也赋值`hello`（`String b=new String("hello");`）那么a和b是否还相等？答案是不相等，因为对象b创建时将`hello`也一同保存在了堆中，常量池中不存在，无法引用。所以是不相等的。

由此我们可以得出结论，**通过构造方法创建的字符串变量都存储在堆中，而直接赋值的字符串都存储在字符串常量池中。**

### 静态变量内存分配

静态变量的内存存放在方法区或者元数据区。所有类的对象都是引用静态变量的地址，因此静态变量可以做到共享。

### 方法内存分配

Java中的方法也是需要分配内存的，在Java中，方法存储在虚拟机栈中。每有一个方法执行就会将该方法的栈帧存入栈中。这里的栈和数据结构中的栈具有一样的性质和操作。栈帧可以理解为栈中的元素。当方法执行完毕后，栈帧会被弹出。而方法中的变量都是直接使用栈中的数据或者引用堆中的数据。

方法无论何种方式结束都会导致出栈。方法有两种结束方式：
1. return返回
2. 抛出异常

## 总结
1. Java 8之前的内存结构以及 Java 8及以后的内存结构

    Java 8之前：

    ![1.8-](https://s2.loli.net/2023/09/26/ayG85gwvRuU9Amo.png)  

    Java 8及以后;

    ![1.8,1.8+](https://s2.loli.net/2023/09/26/4pcMnd7uBOC61SI.png)  

2. JVM结构
    1. 方法区（元数据区）

        内含运行时常量池，存储运行时产生的各种数据、静态变量等。
    2. 堆

        内含字符串常量池，存储字符串常量以及`new`出来的对象。

    3. 栈
        1. 虚拟机栈

            保存Java方法，方法结束后出栈。

        2. 本地方法栈

            保存Native方法。和虚拟机栈一样，方法结束后出栈。

3. 字符串内存分配

    没有通过`new`定义的字符串对象：先看常量池中是否有一样的字符串，有的话直接让对象引用字符串，如果没有则在常量池中创建一个。

    通过`new`定义的字符串对象：存入堆中，直接使用堆中的数据。